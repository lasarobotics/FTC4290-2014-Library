#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     HTGYRO,         sensorAnalogInactive)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Rf,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Rb,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Lf,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lb,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BlowerA,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     BlowerB,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     BlowerC,       tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_2,    BallStorage,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    TubeWinch,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_4,    Kickstand,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    TouchSensor,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_6,    GoalRetainer,         tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***** DEFINES *****/
//#define _FORCE_DEBUG //Uncomment to force using debug (non-optimized) mode
//#define _DISABLE_JOYDISPLAY //Uncomment to disable joystick display
#define _ENABLE_LCDDISPLAY //Uncomment to enable live NXT LCD display


/***** INCLUDES *****/
#include "../drivers/hitechnic-sensormux.h"
#include "../drivers/lego-touch.h"
#include "../lib/naturalization.h" //naturalize RobotC
#include "../lib/logging.h" //logging
#include "../lib/drive.h" //drive trains
#include "../lib/sensor.h" //sensor IO
#include "../lib/i2c.h" //I2C error checking
#include "../lib/options.h" //splash screens and display options
#include "../drivers/hitechnic-irseeker-v2.h"
/***** STATICS *****/
static float k_deadband = 15;
const tMUXSensor touchSensorOne = msensor_S3_3;
const tMUXSensor touchSensorTwo = msensor_S3_4;
/***** VARIABLES *****/
//TJoystick controller; //--declared in JoystickDriver.c, imported by drive.h--

void tele_log_init()
{
  if (log_enabled)
  {
    log_init("tele.txt");
    log_write("GEN","TELE LOG: Started");
  }
}
void init()
{

  servo[TubeWinch] = 127;
  servo[GoalRetainer] = 5;
  servo[Kickstand] = 155;
  servo[BallStorage] = 80;
  servo[TouchSensor] = 65;
  bSmartDiagnostics = true; //true to enable smart diagnostic screen
  bCompetitionMode = true; //true to enable competition mode
  log_enabled = true; //Enable logging in Teleop
  displaySplash("High PHidelity", "Teleop", true);
  eraseDisplay();
  gyro_init(HTGYRO);
  wait1Msec(50);
  nxtbarOn();
  return;
}

/*Control Layout:
Controller 1:
Left Joystick x/y - Strafe and forward for robot
Right Joystick x - Turn
Button 1: Goal Latch Closed
Button 3: Goal Latch Open
Button 4: Gyro Reset
Button 8: Slo-Mo
Controller 2:
Button 1: Blower
Button 2: Intake
Button 3: Ball storage
Button 4: Kickstand
Button 5: Intake slow (lift release)
Button 6: Intake backwards
Button 7: Touch sensor
Timers:
T1:Gyro
T2:Measure RPM
T3:Blower
T4:Global
*/
task main()
{
  float leftFront, leftBack, rightFront, rightBack; // motors
  float y, x, c;
  bool touchsensorenabled = false;
  bool blowerenabled = false;
  bool kickstandenabled = false;
  bool storageclosed = false;
  bool intakeenabled = false;
  bool estop = false;
  bool intakestartup = false;
  long intakelastchecked = -10000;
  int joy1Btn3last = 0;
  int joy1Btn2last = 0;
  int joy1Btn1last = 0;
  //Operator
  int joy2Btn1last = 0;
  int joy2Btn2last = 0;
  int joy2Btn3last = 0;
  int joy2Btn4last = 0;
  int power = 100; //power for drive motors
  /***** BEGIN Mecanum Field Oriented Drive Test *****/
  init();
  StartTask(readSensors);
  StartTask(displaySmartDiags);
  if (bCompetitionMode) {waitForStart();}
  ClearTimer(T4);
  tele_log_init();
  while (true)
  {
    /***** Proportional Motor Control *****/
    getJoystickSettings(joystick); //get all joystick statuses
    if (joy1Btn(8))
    {
      power = 25;
    }
    else { power = 100; }
    //Drive Code
    if ((deadband(k_deadband,joystick.joy1_y1) == 0 &&
      deadband(k_deadband,joystick.joy1_x1) == 0 &&
    deadband(k_deadband,joystick.joy1_x2) == 0)) {
      motor[Lf] = 0;
      motor[Rf] = 0;
      motor[Lb] = 0;
      motor[Rb] = 0;
    }
    else {
      //scale to -1 to 1
      y = ((deadband(k_deadband,joystick.joy1_y1)+1)/128); //strafe
      x = ((deadband(k_deadband,joystick.joy1_x1)+1)/128); //forward/rev
      c = ((deadband(k_deadband,joystick.joy1_x2)+1)/128); //spin

      mecanum_arcadeFOD(y, x, c, gyro_getheading(),
      leftFront, rightFront, leftBack, rightBack);

      motor[Lf] = leftFront*power;
      motor[Rf] = rightFront*power;
      motor[Lb] = leftBack*power;
      motor[Rb] = rightBack*power;
    }
    //Gyro Reset Code
    if(joy1Btn(4) == 1) { gyro_reset(); }
  if(joystick.joy1_TopHat == 0) {
		gyro_reset();
	}
	//90 Deg
	if(joystick.joy1_TopHat == 2) {
		gyro_reset();
		gyro_set(90);
	}
	//180 Deg
	if(joystick.joy1_TopHat == 4) {
		gyro_reset();
		gyro_set(180);
	}
	//270 Deg
	if(joystick.joy1_TopHat == 6) {
		gyro_reset();
		gyro_set(270);
	}
    if(nNxtButtonPressed == kEnterButton) { gyro_reset(); }
    if (joy1Btn(7) == 1){
      servo[GoalRetainer] = 255;
    }
    //Goal Latch Open
    if(joy1Btn(3)== 1 && joy1Btn3last != 1){
      servo[GoalRetainer] = 130;
    }
    //Goal Latch Closed
    if(joy1Btn(1)== 1 && joy1Btn1last != 1){
      servo[GoalRetainer] = 5;
    }

    //Blower Toggle
    if(joy2Btn(1)== 1 && joy2Btn1last != 1){
      if (blowerenabled){
        motor[BlowerA] = 1;
        motor[BlowerB] = 1;
        motor[BlowerC] = 1;
        //Start timer for 1 sec, then set motors to 0
        ClearTimer(T3);
        blowerenabled = false;
        log_write("BL","OFF");
      }
      else{
        ClearTimer(T2);
        nMotorEncoder[BlowerB] = 0;
        motor[BlowerA] = 100;
        motor[BlowerB] = 100;
        motor[BlowerC] = 100;
        blowerenabled = true;
        log_write("BL","ON");
      }
    }
    //If 5 seconds since blower shutdown-brake motors
    if (time1[T3] > 5000 && !blowerenabled){
      motor[BlowerA] = 0;
      motor[BlowerB] = 0;
      motor[BlowerC] = 0;
    }
    //Intake Forwards, back, slow forward
    if (joy2Btn(2) && joy2Btn2last != 1){
      if (intakeenabled){
        intakeenabled = false;
        log_write("IN","OFF");
      }
      else{
        intakelastchecked = -10000;
        nMotorEncoder[Rf] = 4000;
        intakeenabled = true;
        intakestartup = true;
        log_write("IN","ON");
      }
    }
    int nIntakeHealthyVal = 400;

    if (joy2Btn(5) == 1){
      motor[Intake] = 25;
    }
    else if (joy2Btn(6) == 1){
      motor[Intake] = -100;
    }
    else if (joy2Btn(7) == 1){
      motor[Intake] = 100;
    }
    else if (joy2Btn(8) == 1){
      motor[Intake] = -50;
    }
    else if (!intakeenabled){
      motor[Intake] = 0;
    }
    else if (intakeenabled && time1[T4] > intakelastchecked+500){
      if (abs(nMotorEncoder[Rf]) > nIntakeHealthyVal || intakestartup){
        motor[Intake] = 100;
        intakestartup = false;
      }
      else {
        motor[Intake] = -100;
      }
      nMotorEncoder[Rf] = 0;
      intakelastchecked = time1[T4];
    }
    //Storage Toggle
    if(joy2Btn(3)== 1 && joy2Btn3last != 1){
      if (storageclosed){
        servo[BallStorage] = 80;
        storageclosed = false;
      }
      else{
        servo[BallStorage] = 140;
        storageclosed = true;
      }
    }
    //Kickstand Toggle
    if(joy2Btn(4)== 1 && joy2Btn4last != 1){
      if (kickstandenabled){
        servo[Kickstand] = 155;
        kickstandenabled = false;
      }
      else{
        servo[Kickstand] = 31;
        kickstandenabled = true;
      }
    }

    //Touch Sensor Toggle
    if(joy1Btn(2)== 1 && joy1Btn2last != 1){
      if (touchsensorenabled){
        servo[TouchSensor] = 65;
        touchsensorenabled = false;
      }
      else{
        servo[TouchSensor] = 190;
        touchsensorenabled = true;
      }
    }

    //E Stop for blower
    if (!estop && time1[T4] > 117000 && blowerenabled){
      motor[BlowerA] = 1;
      motor[BlowerB] = 1;
      motor[BlowerC] = 1;
      //Start timer for 1 sec, then set motors to 0
      ClearTimer(T3);
      blowerenabled = false;
      estop = true;
    }
    else if (time1[T4] >117000){
      log_stop();
    }

    //VOLTAGE
    if (time100[T2] >= 20) {
      float v = (float)externalBatteryAvg / (float)1000;
      string sv = "";
      StringFormat(sv, "%1.2f", v);
      log_write("V", sv);

      if (blowerenabled) {
        float dEncoderCount = nMotorEncoder[BlowerB];
        float dTime = time1[T2];
        float rpm = (4439 * (dEncoderCount))/(dTime);
        string s = "";
        StringFormat(s,"RPM: %1.2f",rpm);
        nxtDisplayTextLine(5, s);
        log_write("BL",s);
        nMotorEncoder[BlowerB] = 0;
      }

      //Clear for next calculation
      ClearTimer(T2);
    }
    //Winch
    if (deadband(k_deadband,joystick.joy2_y2) == 0){
      servo[TubeWinch] = 127;
    }
    else{
      servo[TubeWinch] = (deadband(k_deadband,joystick.joy2_y2))+127;
    }
    joy1Btn1last = joy1Btn(1);
    joy1Btn2last = joy1Btn(2);
    joy1Btn3last = joy1Btn(3);
    joy2Btn1last = joy2Btn(1);
    joy2Btn2last = joy2Btn(2);
    joy2Btn3last = joy2Btn(3);
    joy2Btn4last = joy2Btn(4);
    //DO NOT REMOVE THIS WAIT, See issue #11
    nxtDisplayTextLine(4, "%i", gyro_getheading());
    wait1Msec(5);
  }
}
