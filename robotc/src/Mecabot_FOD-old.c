#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Rf,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Rb,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Lf,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lb,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***** DEFINES *****/
//#define _FORCE_DEBUG //Uncomment to force using debug (non-optimized) mode
//#define _DISABLE_JOYDISPLAY //Uncomment to disable joystick display
#define _ENABLE_LCDDISPLAY //Uncomment to enable live NXT LCD display


/***** INCLUDES *****/
#include "../lib/naturalization.h" //naturalize RobotC
#include "../lib/logging.h" //logging
#include "../lib/drive.h" //drive trains
#include "../lib/sensor.h" //sensor IO
#include "../lib/options.h" //splash screens and display options
#include "../drivers/hitechnic-irseeker-v2.h"
/***** STATICS *****/
static float k_deadband = 15;
const tMUXSensor touchSensorOne = msensor_S3_3;
const tMUXSensor touchSensorTwo = msensor_S3_4;
/***** VARIABLES *****/
//TJoystick controller; //--declared in JoystickDriver.c, imported by drive.h--
void tele_log_init()
{
  if (log_enabled)
  {
    log_init("tele.txt",false);
    log_write("GEN","TELE LOG: Started");
  }
}
void init()
{
  bSmartDiagnostics = true; //true to enable smart diagnostic screen
  bCompetitionMode = true; //true to enable competition mode
  log_enabled = true; //Enable logging in Teleop
  displaySplash("High PHidelity", "Teleop", true);
  eraseDisplay();
  gyro_init(HTGYRO);
  wait1Msec(50);
  nxtbarOn();
  return;
}

task main()
{
  float leftFront, leftBack, rightFront, rightBack; // motors
  float y, x, c;
  int power = 100;
  /***** BEGIN Mecanum Field Oriented Drive Test *****/
  init();
  StartTask(readSensors);
  StartTask(displaySmartDiags);
  if (bCompetitionMode) {waitForStart();}
  ClearTimer(T4);
  tele_log_init();
  while (true)
  {
    /***** Proportional Motor Control *****/
    getJoystickSettings(joystick); //get all joystick statuses
    if (joy1Btn(8))
    {
      power = 25;
    }
    else { power = 100; }
    //Drive Code
    if ((deadband(k_deadband,joystick.joy1_y1) == 0 &&
      deadband(k_deadband,joystick.joy1_x1) == 0 &&
    deadband(k_deadband,joystick.joy1_x2) == 0)) {
      motor[Lf] = 0;
      motor[Rf] = 0;
      motor[Lb] = 0;
      motor[Rb] = 0;
    }
    else {
      //scale to -1 to 1
      y = ((deadband(k_deadband,joystick.joy1_y1)+1)/128); //strafe
      x = ((deadband(k_deadband,joystick.joy1_x1)+1)/128); //forward/rev
      c = ((deadband(k_deadband,joystick.joy1_x2)+1)/128); //spin

      mecanum_arcadeFOD(y, x, c, gyro_getheading(),
      leftFront, rightFront, leftBack, rightBack);

      motor[Lf] = leftFront*power;
      motor[Rf] = rightFront*power;
      motor[Lb] = leftBack*power;
      motor[Rb] = rightBack*power;
    }
    //Gyro Reset Code
    if(joy1Btn(4) == 1) { gyro_reset(); }
    nxtDisplayTextLine(4, "%i", gyro_getheading());
    wait1Msec(5);
  }
}
