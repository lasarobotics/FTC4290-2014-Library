#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTIRS2,             sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Rf,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Rb,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Lf,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lb,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Autonomous Program Headers for Mecabot NoStep
 * Contains methods for Mecabot autonomous
 **/

/***** DEFINES *****/
//#define _FORCE_DEBUG //Uncomment to force using debug (non-optimized) mode
#define _DISABLE_JOYDISPLAY //Uncomment to disable joystick display
#define _ENABLE_LCDDISPLAY //Uncomment to enable live NXT LCD display

/***** INCLUDES *****/
#include "../../lib/naturalization.h" //naturalize RobotC
#include "../../lib/drive.h" //drive trains
#include "../../lib/i2c.h" //I2C error checking
#include "../../lib/display.h" //splash screens
#include "../../lib/ir.h" //other math

/***** CONSTANTS *****/
const int ir_threshold = 100; //IR threshold between positions 2 and 3

void auto_init()
{

}
float getZone(float avgS3,float avgS4,bool newIR){
  //Change based on sensor
  float zone = 1;
	if ((avgS3 > 40) && (avgS4 > 40)) {
	   zone = 2;
	} else if ((avgS3 < 10) && (avgS4 > 50)) {
	   zone = 3;
	}
  nxtDisplayCenteredTextLine(3, "%i", zone);
	return zone;
}
/**
 * Center IR
 * Move until the robot's gyro sensor is aligned to the goal.
 */
void centerIR(int zone,bool scanright){
    float leftFront, leftBack, rightFront, rightBack;
    int irS1,irS2,irS3,irS4,irS5;
    float avgS3,avgS4;
    //move until IR
    float xdir = -1;
    if(scanright){xdir = 1;}
    mecanum_arcade(0, xdir, 0, leftFront, leftBack, rightFront, rightBack);
    motor[Lf] = leftFront*50;
    motor[Rf] = rightFront*50;
    motor[Lb] = leftBack*50;
    motor[Rb] = rightBack*50;
    int count = 0;
    while (avgS4 < ir_threshold)
    {
        HTIRS2readAllACStrength(HTIRS2, irS1, irS2, irS3, irS4, irS5);
        ir_moveavg(3,irS3,avgS3);
        ir_moveavg(4,irS4,avgS4);
        nxtDisplayCenteredTextLine(4, "IR3: %i", irS3);
        nxtDisplayCenteredTextLine(5, "IR4: %i", irS4);
        nxtDisplayCenteredTextLine(6, "Avg IR3: %i", avgS3);
        nxtDisplayCenteredTextLine(7, "Avg IR4: %i", avgS4);
        count++;
    }
    wait1Msec(100); //move for a little bit more
    motor[Lf] = 0;
    motor[Rf] = 0;
    motor[Lb] = 0;
    motor[Rb] = 0;
    wait1Msec(20);

    //Place ball sequence
    forward_Mecanum(800, 100, 0, Lf, Lb, Rf, Rb);
}

//TODO enum irAction

//TODO task readIR() in ir.h

/***** PLACE IN CENTER GOAL *****/
// returns current zone (1,2,3)
float auto_placeCenterGoal(bool newIR)
{
    forward_Mecanum(1700, 100, 0, Lf, Lb, Rf, Rb);
    wait10Msec(30);
    forward_Mecanum(400, 0, 100, Lf, Lb, Rf, Rb);
    int irS1,irS2,irS3,irS4,irS5;
    float avgS3,avgS4;
    for (int i = 0; i < 50; i++){
      HTIRS2readAllACStrength(HTIRS2, irS1, irS2, irS3, irS4, irS5);
      ir_moveavg(3,irS3,avgS3);
      ir_moveavg(4,irS4,avgS4);
      wait1Msec(10);
    }

    //Let things settle down
    wait10Msec(10);
    float zone = getZone(irS3,irS4,newIR);
    //Wait for a little bit
    wait10Msec(100);

    if (zone == 3){
      centerIR(zone,true);
    }
    if (zone <= 2){
      //Nav to zone 2
      forward_Mecanum(1000, 0, -100, Lf, Lb, Rf, Rb);
      wait10Msec(100);
      turnToDeg_Mecanum(32, 100, Lf, Lb, Rf, Rb);
      wait1Msec(100);
      if (zone == 2) { centerIR(zone,false); }
    }
    if (zone == 1){
      //Nav to zone 1 (farthest)
      forward_Mecanum(1000, 0, -100, Lf, Lb, Rf, Rb);
      wait10Msec(100);
      turnToDeg_Mecanum(85, 70, Lf, Lb, Rf, Rb);
      wait1Msec(100);
      forward_Mecanum(2100, 0, -100, Lf, Lb, Rf, Rb);
      centerIR(zone,false);
    }

    return zone;
}

/**** PLACE IN KICKSTAND
      (from already placing a ball in center goal) ****/
void auto_kickstandFromCenterGoal(int zone)
{
    //hook the goal
    wait1Msec(250);
    forward_Mecanum(1300, 0, 100, Lf, Lb, Rf, Rb);
    wait1Msec(250);
    forward_Mecanum(600, 100, 0, Lf, Lb, Rf, Rb);
    wait1Msec(250);
    forward_Mecanum(1000, 0, -100, Lf, Lb, Rf, Rb); //hit the goal
    wait1Msec(250);
    forward_Mecanum(2200, 100, 0, Lf, Lb, Rf, Rb); //continue moving
}
