#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     PSPNXV4,        sensorI2CCustomFastSkipStates)
#pragma config(Motor,  mtr_S1_C1_1,     drive_right,   tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     drive_left,    tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***** DEFINES *****/
//#define _FORCE_DEBUG //Uncomment to force using debug (non-optimized) mode
#define _DISABLE_JOYDISPLAY //Uncomment to disable joystick display
#define _ENABLE_LCDDISPLAY //Uncomment to enable live NXT LCD display

/***** INCLUDES *****/
#include "../lib/naturalization.h" //naturalize RobotC
#include "../lib/joystick.h" //joystick
#include "../lib/motor.h" //motor,servo,encoder
#include "../drivers/mindsensors-ps2ctrl-v4.h" //mindsensors stuffs
#include "../drivers/hitechnic-gyro.h" //gyroscope

/***** STATICS *****/
static bool competitionmode = false; //set to true to wavoid waiting for FCS

/***** VARIABLES *****/
float rotSpeed = 0;
float heading = 0;

void init()
{
  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	eraseDisplay();
	wait1Msec(500);
	// Prepare gyro offset
	HTGYROstartCal(HTGYRO);
	wait1Msec(50);
  return;
}

task calibrate()
{
	while (true)
  {
    // Wait until 20ms has passed
    while (time1[T1] < 20)
      wait1Msec(1);

    // Reset the timer
    time1[T1]=0;

    // Read the current rotation speed
    rotSpeed = HTGYROreadRot(HTGYRO);

    // Calculate the new heading by adding the amount of degrees
    // we've turned in the last 20ms
    // If our current rate of rotation is 100 degrees/second,
    // then we will have turned 100 * (20/1000) = 2 degrees since
    // the last time we measured.
    heading += rotSpeed * 0.02;

    // Display our current heading on the screen
    nxtDisplayCenteredBigTextLine(6, "%2.0f", heading);
  }
}

task main()
{
  init();

  // This is the struct that holds all the info on all buttons and joypads/sticks
  tPSP controller;

  StartTask(calibrate, 8);

  if (competitionmode) {waitForStart();}

  while (true)
  {
	  // Read the state of the buttons
    PSPV4readButtons(PSPNXV4, controller);

    //y-axis is inverted
    motor[drive_left] = -controller.joystickLeft_y;
    motor[drive_right] = -controller.joystickRight_y;

    if(nNxtButtonPressed == kEnterButton)
    {
    	//Reset heading to zero
    	heading = 0;
    }

  }
}
