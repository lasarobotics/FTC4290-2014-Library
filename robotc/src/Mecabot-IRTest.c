#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     IR,             sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Rf,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Rb,            tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Lf,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lb,            tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***** DEFINES *****/
#define _FORCE_DEBUG //Uncomment to force using debug (non-optimized) mode
//#define _DISABLE_JOYDISPLAY //Uncomment to disable joystick display
#define _ENABLE_LCDDISPLAY //Uncomment to enable live NXT LCD display

/***** INCLUDES *****/
#include "../lib/naturalization.h" //naturalize RobotC
#include "../lib/drive.h" //drive trains
#include "../lib/gyro.h" //gyroscope and FOD
#include "../lib/i2c.h" //I2C error checking
#include "../lib/display.h" //splash screens
#include "../drivers/hitechnic-irseeker-v2.h" //IR diver
/***** STATICS *****/
static float k_deadband = 15;

/***** VARIABLES *****/
//TJoystick controller; //--declared in JoystickDriver.c, imported by drive.h--
float rotatlast = 0.0; //last rotation values where
bool contsearch = true;
task getIR()
{
	rotatlast = 0.0;
	while (contsearch) {
		int irnum = HTIRS2readDCDir(IR);
		nxtDisplayString(3, "%i", irnum);
		if (irnum != 5)
		{
			rotatlast = gyro_getheading();
			return;
		}
	}
}
void writeIRToFile(float millis,TFileHandle hFileHandle,TFileIOResult nIOResult){
	byte CR = 0x13;   // define CR (carriage return)
  byte LF = 0x10;   // define LF (line feed)
	float ir = HTIRS2readDCDir(IR);
	string s;
	StringFormat(s,"%f,%f",millis,ir);
	WriteText(hFileHandle, nIOResult, s);         // write 'sMessageToWrite' to the file
  WriteByte(hFileHandle, nIOResult, CR);                      // write 'CR' to the file (carriage return)
  WriteByte(hFileHandle, nIOResult, LF);                      // write 'LF' to the file (line feed)
}
void executeMidpoint(){

	 int turnspeed = 100;
	 contsearch = true;
	 StartTask(getIR, 7);
	 turnToDeg_Mecanum(90,turnspeed, Lf,Lb,Rf,Rb);
	 contsearch = false;

	 float rotright = rotatlast;
	 turnToDeg_Mecanum(0,turnspeed, Lf,Lb,Rf,Rb);

	 contsearch = true;
	 StartTask(getIR, 7);
	 turnToDeg_Mecanum(270,turnspeed, Lf,Lb,Rf,Rb);
	 contsearch = false;

	 float rotleft = rotatlast;
	 float midpoint = (rotright + rotleft) / 2;

	 turnToDeg_Mecanum(concGyro(midpoint),turnspeed, Lf,Lb,Rf,Rb);
	 nxtDisplayString(3, "%f %f", rotleft, rotright);
	 while (true){}
}
void init()
{
    bSmartDiagnostics = false; //true to enable smart diagnostic screen
    bCompetitionMode = false; //true to enable competition mode

    displaySplash("NoStep", "Auto IR Test", true);

    bool ok = true;
    while(!ok)
    {
        const int testcount = 2;
	    bool test[testcount] = {
	        errorcheck(1,0,1,MOTORCON),
	        errorcheck(1,0,2,MOTORCON)};
	    string desc[testcount] = {"MC1-1","MC1-2"};
	    ok = error_display(test,desc,testcount);
	    if (!ok) {
	        PlayTone(440, 50);
	        if (test[0] == false && test[1] == false){
	            nxtDisplayCenteredTextLine(7, "Reboot MC!");
	        }
	    }
	    else { ClearSounds(); }
    }

    eraseDisplay();
    gyro_init(HTGYRO);
    wait1Msec(50);
    nxtbarOn();
    return;
}

task main()
{
  	TFileHandle   hFileHandle;              // will keep track of our file
  	TFileIOResult nIOResult;                // will store our IO results
  	string        sFileName = "data.txt";   // the name of our file
  	int           nFileSize = 1000;          // will store our file size
  	byte CR = 0x13;   // define CR (carriage return)
  	byte LF = 0x10;   // define LF (line feed)
    /***** BEGIN Mecanum Field Oriented Drive Test *****/
    init();
    StartTask(gyro_calibrate, 8);
//    StartTask(displaySmartDiags, 255);
		//Write to file
    OpenWrite(hFileHandle, nIOResult, sFileName, nFileSize);    // open the file for writing (creates the file if it does not exist)
    WriteText(hFileHandle, nIOResult, "Time,IR");         			// write 'sMessageToWrite' to the file
  	WriteByte(hFileHandle, nIOResult, CR);                      // write 'CR' to the file (carriage return)
  	WriteByte(hFileHandle, nIOResult, LF);                      // write 'LF' to the file (line feed)
    /***** Movement Sequence FROM PARKING! *****/

    // 1. Start robot in center of parking zone touching wall
    // 2. Check if IR is straight ahead (position 1)

    // 2.1. If true, Move forward and PLACE
    // 3. Move to position such that the robot is same distance from goal at and facing position 2
    // 4. If 5, check that you are at a resonable gyro angle then perform midpoint method
    // 5. Calculate midpoint between angle found at 3/4 and 6/7 and confirm with gyro angle.
    // 6. If fails, continue to next position and repeat
		turnToDeg_Mecanum(320,100,Lf,Lb,Rf,Rb);
		time1[T1] = 0;
    while(time1[T1] < 5000){
    		float leftFront,leftBack,rightFront,rightBack;
    		mecanum_arcade(0,1,0,leftFront,rightFront,leftBack,rightBack);
    		motor[Lf] = leftFront*100;
    		motor[Lb] = leftBack*100;
    		motor[Rf] = rightFront*100;
    		motor[Rb] = rightBack*100;
    		writeIRToFile(time1[T1],hFileHandle,nIoResult);
  	}
  	Close(hFileHandle, nIOResult);                              // close the file (DON'T FORGET THIS STEP!)


    //turnToDeg_Mecanum(270,100, Lf, Lb, Rf, Rb);
    //forward_Mecanum(3500, 100, Lf, Lb, Rf, Rb);
    //turnToDeg_Mecanum(270, 100, Lf, Lb, Rf, Rb);
    //forward_Mecanum(2000, 100, Lf, Lb, Rf, Rb);
    //turnToDeg_Mecanum(180, 100, Lf, Lb, Rf, Rb);
}
