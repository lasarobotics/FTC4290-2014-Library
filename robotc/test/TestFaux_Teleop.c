#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IR,             sensorI2CCustom)
#pragma config(Sensor, S3,     ArmLimit,       sensorTouch)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     ArmB,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     ArmA,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     DriveLeft,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DriveRight,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     ArmC,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    ArmRelease,           tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    ManipL,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    ManipR,               tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    Auto,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// RobotC pre-generated schematic above.  Do NOT attempt to change manually
// NOR move to another locale in code.

//////////
// INFO //
//////////

// This is an implementation of the Faux drive system on 4290.
// Oh, an there's no .h file, because that would be pointless.


/////////////
// STATICS //
/////////////

#define _DEBUG_  //define this to activate debug info

static float Global_Deadband = 15.0;

static float Drive_Power_Min = 0.1;
static float Drive_Power_Max = 1.0;

static float Manip_Default = 128;
static float Manip_Speed = 0.5;

static float Arm_Power = 100;
static float Arm_Deadband = 15.0;
static float Flag_Power = 100;
static float Arm_Release_Open = 255;
static float Arm_Release_Closed = 155;
static float Auto_Open = 240;
static float Auto_Closed = 15;


//////////////////////////////
// DEFINITIONS AND INCLUDES //
//////////////////////////////
#include "TestFaux_Functions.c"


///////////////
// VARIABLES //
///////////////

float Manip_Pos = 128;
bool killall = false;

//////////////
// CONTROLS //
//////////////

// ** DRIVER **
// LY + RY : Tank Drive
// 6       : Slow Movement

// ** OPERATOR **
// LY      : Arm
// RY      : Manipulator
// 1       : Flag
// 8       : Arm Release
// 2       : Auto Servo [TEST ONLY]


////////////////////
// INITIALIZATION //
////////////////////

void initialize()
{
	// ** INITIALIZE SENSORS **

	Manip_Pos = Manip_Default;
	servo[ArmRelease] = Arm_Release_Closed;
	servo[Auto] = Auto_Closed;
	servo[ManipL] = Manip_Pos;
	servo[ManipR] = 255 - Manip_Pos;

	wait1Msec(150); //wait for sensor stability (150ms)
	return;
}

//////////////////
// DEBUG THREAD //
//////////////////

task DebugThread()
{
	while(!killall)
	{
  	nxtDisplayTextLine(2, "%d", SensorValue[ArmLimit]);
	}
}


/////////////////
// MAIN THREAD //
/////////////////

task main()
{

	float _motor_multi = 1.0;
	float _arm_pow = 0.0;

	nxtDisplayTextLine(2, "INITIALIZING");
	initialize(); //initialize sensors and perform RobotC junk
	StartTask(DebugThread); //start the display
	nxtDisplayTextLine(2, "WAITING");
	waitForStart();
	nxtDisplayTextLine(2, "RUNNING!");

	while (true)
	{
		// ** GET JOYSTICK STATE **
		getJoystickSettings(joystick); // Get current joystick settings


		// ** DRIVER **

		if(joy1Btn(6) == 1) //if slow button pressed
			{ _motor_multi = Drive_Power_Min; } //then set motor speed to 30%
			else { _motor_multi = Drive_Power_Max; } //else set motor speed to 100% (normal)

		motor[DriveLeft] = deadband(Global_Deadband, norm_motor(joystick.joy1_y1 * _motor_multi)) ; //left drive
		motor[DriveRight] = deadband(Global_Deadband, norm_motor(joystick.joy1_y2 * _motor_multi)) ; //right drive


		// ** OPERATOR **

		//ARM
		if (abs(joystick.joy2_y1) > Arm_Deadband) //if joystick value reaches movement threshold
		{
			if (joystick.joy2_y1 < 0) //then move arm at full power
			{ _arm_pow = -Arm_Power; }
			else { _arm_pow = Arm_Power; }
		}
		else { _arm_pow = 0; } //else, do not move arm

		if ((_arm_pow < 0) && (SensorValue[ArmLimit] == 1)) //if NXT stop button is pushed and Arm is trying to go down
		{
			_arm_pow = 0; //stop arm from going down
		}

		motor[ArmA] = _arm_pow; //arm movement
		motor[ArmB] = _arm_pow;
		motor[ArmC] = _arm_pow;

		//MANIPULATOR
		Manip_Pos += deadband(Global_Deadband, joystick.joy2_y2) * Manip_Speed / 127;
		Manip_Pos = coerce(1, 255, Manip_Pos);
		servo[ManipL] = Manip_Pos;
		servo[ManipR] = 255 - Manip_Pos;

		//FLAG
		if (joy2Btn(1) == 1) { motor[Flag] = Flag_Power; }
		else { motor[Flag] = 0; }

		//ARM RELEASE
		if (joy2Btn(8) == 1) { servo[ArmRelease] = Arm_Release_Open; }
		else { servo[ArmRelease] = Arm_Release_Closed; }

		//AUTO SERVO
		if (joy2Btn(2) == 1) { servo[Auto] = Auto_Open; }
		else { servo[Auto] = Auto_Closed; }
	}
	killall = true;
}
